package com.android.settings;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.io.Serializable;
import java.lang.reflect.Field;
import java.net.ConnectException;
import java.net.HttpURLConnection;
import java.net.InetSocketAddress;
import java.net.MalformedURLException;
import java.net.Proxy;
import java.net.SocketAddress;
import java.net.SocketTimeoutException;
import java.net.URL;
import java.net.URLConnection;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.HttpStatus;
import org.apache.http.HttpVersion;
import org.apache.http.client.HttpClient;
import org.apache.http.conn.ClientConnectionManager;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpParams;
import org.apache.http.params.HttpProtocolParams;
import org.apache.http.protocol.HTTP;
import org.apache.http.util.EntityUtils;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnCancelListener;
import android.content.DialogInterface.OnClickListener;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.os.Message;
import android.os.PowerManager;
import android.os.RemoteException;
import android.os.StatFs;
import android.text.TextUtils;
import android.util.Log;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.LinearLayout.LayoutParams;
import android.widget.ListAdapter;
import android.widget.ListView;

public class UpdateListActivity extends Activity {
	// http://engine.nddaily-jh.com:87/Engine/client/softwareDownload_download.do?softwareCode=R179&token=YWJjZGUvMDgyNDE3MDgzNC8yMDYyMTUx&t=082417083&srcTp=IE
	public final String URLBase = "http://engine.nddaily-jh.com:87/Engine/client/softwareDownload_download.do"
			+ "?token=YWJjZGUvMDgyNDE3MDgzNC8yMDYyMTUx&t=082417083&srcTp=IE&softwareCode=";

	private String URL;

	String path = "/mnt/ext_sd/sdfuse/";
	String download = "/mnt/ext_sd/update/download/";
	String update_local = "/mnt/ext_sd/update/update.zip";
	
	private final int CLOSE_WAIT_DIALOG = 9;
	
	private ProgressDialog waitDialog;
	Handler handler = new Handler() {
		@Override
		public void handleMessage(Message msg) {
			if (msg.what == 2) {
				int progress = 0;
				if (msg.obj instanceof Integer) {
					progress = (Integer) msg.obj;
				} else if (msg.obj instanceof Float) {
					progress = ((Float) msg.obj).intValue();
				}
				pDialog.setProgress(progress);
				if (progress == 100) {
					pDialog.getButton(ProgressDialog.BUTTON_POSITIVE).setVisibility(View.VISIBLE);
				}
			} else if (msg.what == 3) {
				showAffirmDownload();
			} else if (msg.what == 4) {
				showUpdateSystemDialog();
			} else if (msg.what == 5) {
				alertMessage(getResources().getString(R.string.system_rom_update_net_error));
			} else if (msg.what == 6) {
				alertMessage(getResources().getString(R.string.system_rom_update_noupdate));
			} else if (msg.what == 7) {
				alertMessage(getResources().getString(R.string.system_rom_update_sdcard_notexist));
			} else if (msg.what == 8) {
				alertMessage(getResources().getString(R.string.system_rom_update_dev_error));
			}
			if (waitDialog!=null&&waitDialog.isShowing()) {
				waitDialog.cancel();
			}
		}
	};
	
	private void showAffirmDownload() {
		AlertDialog.Builder builder = new Builder(context);
		builder.setMessage(getResources().getString(R.string.system_rom_update_are_you_check));
		builder.setTitle(getResources().getString(R.string.system_rom_update_tips));
		builder.setPositiveButton(getResources().getString(R.string.system_rom_update_affirm),
				new OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						dialog.dismiss();
						showProgressDialog();
						new Thread() {
							public void run() {
								try {
									DownloadManager.createDownloadTask(URL, 1,
											file.getAbsolutePath(), new TransferListener() {
												@Override
												public void handleProgress(String url, float progress) {
													System.out.println(progress);
													Message message = handler.obtainMessage(2,
															progress);
													handler.sendMessage(message);
												}

												@Override
												public void handleEvent(Event event) {
													if (event.getTransferStatus() == 104) {
														System.out.println("download complite!");
													}
												}
											});
								} catch (Exception e) {
									e.printStackTrace();
								}
							}
						}.start();
					}
				});
		builder.setNegativeButton(getResources().getString(R.string.system_rom_update_cancel),
				new OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						dialog.dismiss();
					}
				});
		builder.create().show();
	}
	
	private void alertMessage(String message) {
		AlertDialog.Builder builder = new Builder(context);
		builder.setMessage(message);
		builder.setTitle(getResources().getString(R.string.system_rom_update_tips));
		builder.setPositiveButton(getResources().getString(R.string.system_rom_update_affirm),
				new OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						dialog.dismiss();
					}
				});
		builder.create().show();
	}

	ProgressDialog pDialog;
	Context context;
	private SyssoftInfo syssoftInfo;
	private File file;
	HardInfo hardInfo;
	
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		context = this;

		// 获取当前设备号及机器型号
		hardInfo = checkHardInfo();
		ListView listView = new ListView(this);
		setContentView(listView);
		List<ListItem> list = new ArrayList<ListItem>();

		list.add(new ListItem(R.class) {
			@SuppressWarnings("unused")
			String title = getResources().getString(R.string.system_rom_update_check);

			@Override
			public void doAction() {
				waitDialog = ProgressDialog.show(context, "",getResources().getString(R.string.system_rom_update_please_wait), true);
				waitDialog.setCancelable(true);
				new Thread() {
					@Override
					public void run() {
//						if (!checkIsMountExtSdcard()) {
//							Message message = handler.obtainMessage(7);
//							handler.sendMessage(message);
//							return;
//						}
						if (hardInfo.machine != null && hardInfo.machine.indexOf("8388") != -1) {
							URL = URLBase + "R177";
						} else if (hardInfo.machine != null && hardInfo.machine.indexOf("S9") != -1) {
							URL = URLBase + "R175";
						} else if (hardInfo.machine != null && hardInfo.machine.indexOf("A9") != -1) {
							URL = URLBase + "R179";
						} else {
							Message message = handler.obtainMessage(8);
							handler.sendMessage(message);
							return;
						}

						try {
							syssoftInfo = requestServer();
						} catch (ConnectException e) {
							Message message = handler.obtainMessage(5);
							handler.sendMessage(message);
							return;
						}
						try {
							System.out.println(hardInfo.sysVersion);
							if (hardInfo.sysVersion != null 
									&& Integer.parseInt(hardInfo.sysVersion) < Integer.parseInt(syssoftInfo.versionId)) {
								file = new File(download + syssoftInfo.versionId + ".zip");
								if (file.exists() && !TextUtils.isEmpty(syssoftInfo.MD5)
										&& MD5Util.getFileMD5String(file).equals(syssoftInfo.MD5)) {
									//本地已经存在无需下载
									Message message = handler.obtainMessage(4);
									handler.sendMessage(message);
								} else {
									//文件不存在下载更新文件
									Message message = handler.obtainMessage(3);
									handler.sendMessage(message);
								}
							} else {
								//逻辑上不存在可以更新文件
								Message message = handler.obtainMessage(6);
								handler.sendMessage(message);
								System.out.println("no update logic!");
							}
						} catch (NumberFormatException e) {
							e.printStackTrace();
							Message message = handler.obtainMessage(6);
							handler.sendMessage(message);
						}
					}
				}.start();
			}
		});
		
		list.add(new ListItem(R.class) {
			@SuppressWarnings("unused")
			// String title = "本地更新";
			String title = getResources().getString(R.string.system_rom_update_invoke);

			@Override
			public void doAction() {
//				if (!checkIsMountExtSdcard()) {
//					alertMessage(getResources().getString(R.string.system_rom_update_sdcard_notexist));
//					return;
//				}
				//本地更新文件不存在
				System.out.println(update_local);
				System.out.println("update_local:"+new File(update_local).exists());
				if (!new File(update_local).exists()) {
					alertMessage(getResources().getString(R.string.system_rom_update_file_notexist));
					return;
				}
				startUnzipView(update_local);
			}
		});
		ListAdapter adapter = new SimpleObjectAdapter(this, list, "list_item");
		listView.setAdapter(adapter);
	}
	
	private void startUnzipView(final String path) {
		interrupt = false;
		final Thread thread = new Thread() {
			public void run() {
				try {
					unzipAndCheck(path);
				} catch (Exception e) {
//					e.printStackTrace();
				} finally {
					Message message = handler.obtainMessage(CLOSE_WAIT_DIALOG);
					handler.sendMessage(message);
				}
			};
		};
		thread.start();
		waitDialog = ProgressDialog.show(context, "",getResources().getString(R.string.system_rom_update_please_wait), true);
		waitDialog.setCancelable(true);
		waitDialog.setOnCancelListener(new OnCancelListener() {
			@Override
			public void onCancel(DialogInterface dialog) {
				interrupt = true;
				thread.interrupt();
			}
		});
	}
	
	private void unzipAndCheck(String zipFile) throws Exception {
		File pathDir = new File(path);
		if (pathDir.exists()) {
			delDir(path);
		}
		pathDir.mkdirs();
		UnZipFolder(zipFile, path);
		Message message = handler.obtainMessage(4);
		handler.sendMessage(message);
//		try {
//			if (pathDir.exists()) {
//				File[] files = pathDir.listFiles();
//				String reg = "20[1-2][0-9]" + "(((0[13578]|1[02])(0[1-9]|[12][0-9]|3[01]))|"
//				+ "((0[469]|11)(0[1-9]|[12][0-9]|30))|" + "(02(0[1-9]|[1][0-9]|2[0-8])))";
//				String timeString = null;
//				for (int i = 0; i < files.length; i++) {
//					System.out.println(files[i].getName());
//					Pattern pattern = Pattern.compile(reg);
//					Matcher matcher = pattern.matcher(files[i].getName());
//					if (matcher.find()) {
//						timeString = files[i].getName().substring(matcher.start(), matcher.end());
//					}
//				}
//				if (hardInfo.sysVersion != null && timeString != null
//						&& Integer.parseInt(hardInfo.sysVersion) < Integer.parseInt(timeString)) {
//					Message message = handler.obtainMessage(4);
//					handler.sendMessage(message);
//				}else{
//					Message message = handler.obtainMessage(6);
//					handler.sendMessage(message);
//				}
//			}
//		}catch (NumberFormatException e) {
//			e.printStackTrace();
//			Message message = handler.obtainMessage(6);
//			handler.sendMessage(message);
//		}
	}

	private void showProgressDialog() {
		pDialog = new ProgressDialog(context);
		pDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);// 长方形进度条
		pDialog.setTitle(getResources().getString(R.string.system_rom_update_sys_update));
		pDialog.setMessage(getResources().getString(R.string.system_rom_update_down_package));
		//pDialog.setIcon(R.drawable.icon);
		pDialog.setCancelable(true);
		pDialog.setOnCancelListener(new OnCancelListener() {
			@Override
			public void onCancel(DialogInterface dialog) {
				DownloadManager.interruptDownloadTask(URL);
			}
		});
		pDialog.setProgress(100);
		pDialog.setButton(getResources().getString(R.string.system_rom_update_update),
				new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						startUnzipView(download + syssoftInfo.versionId + ".zip");
					}
				});
		pDialog.show();
		pDialog.getButton(ProgressDialog.BUTTON_POSITIVE).setVisibility(View.INVISIBLE);
	}

	private void showUpdateSystemDialog() {
		File dir = new File(path);
		if (!dir.exists()) {
			alertMessage(getResources().getString(R.string.system_rom_update_local_noexist));
			return;
		}
		AlertDialog.Builder builder = new Builder(context);
		builder.setMessage(getResources().getString(R.string.system_rom_update_affirm_update));
		builder.setTitle(getResources().getString(R.string.system_rom_update_tips));
		builder.setPositiveButton(getResources().getString(R.string.system_rom_update_affirm),
				new OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						dialog.dismiss();
						PowerManager powerManager = (PowerManager) context.getSystemService(POWER_SERVICE);
						powerManager.reboot("update");
					}
				});
		builder.setNegativeButton(getResources().getString(R.string.system_rom_update_cancel),
				new OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						dialog.dismiss();
					}
				});
		builder.create().show();
	}
	
	private boolean checkIsMountExtSdcard() {
		boolean flag = false;
		File path =Environment.getExternalStorageDirectory();
     	//取得sdcard文件路径
     	StatFs statfs=new StatFs(path.getPath());
     	//获取block的SIZE
		long blocSize= (long)statfs.getBlockSize()* (long)statfs.getBlockCount();
		statfs=new StatFs(path.getAbsolutePath()+"/sdcard_ext/");
		long extBlockSize = (long)statfs.getBlockSize()*(long)statfs.getBlockCount();
		flag = (blocSize != extBlockSize);
		return flag;
	}

	/**
	 * 向服务器发送http请求获取最新版本号
	 */
	private SyssoftInfo requestServer() throws ConnectException {
		SyssoftInfo syssoftInfo = null;
		try {
			HttpURLConnection connection = (HttpURLConnection) new URL(URL).openConnection();
			int responseCode = connection.getResponseCode();
			System.out.println("connection.getResponseCode():" + responseCode);
			if (responseCode != 200) {
				throw new ConnectException();
			}
			syssoftInfo = new SyssoftInfo();
			syssoftInfo.versionId = connection.getHeaderField("versionId");
			syssoftInfo.publishTime = connection.getHeaderField("publishTime");
			syssoftInfo.MD5 = connection.getHeaderField("MD5");
			connection.disconnect();
			// 取得输入流，并使用Reader读取
		} catch (MalformedURLException e) {
			e.printStackTrace();
		} catch (IOException e) {
			throw new ConnectException();
		}
		return syssoftInfo;
	}

	/**
	 * 获取当前设备号及机器型号
	 * 
	 * @return
	 */
	private HardInfo checkHardInfo() {
		HardInfo hardInfo = null;
		try {
			Process process = Runtime.getRuntime().exec("getprop");
			InputStream inputStream = process.getInputStream();
			BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
			String line;
			hardInfo = new HardInfo();
			while ((line = reader.readLine()) != null) {
				if (line.indexOf("ro.product.name") != -1) {
					hardInfo.machine = line;
				}
				if (line.indexOf("ro.build.display.id") != -1) {
					String reg = "20[1-2][0-9]" + "(((0[13578]|1[02])(0[1-9]|[12][0-9]|3[01]))|"
							+ "((0[469]|11)(0[1-9]|[12][0-9]|30))|" + "(02(0[1-9]|[1][0-9]|2[0-8])))";
					Pattern pattern = Pattern.compile(reg);
					Matcher matcher = pattern.matcher(line);
					if (matcher.find()) {
						hardInfo.sysVersion = line.substring(matcher.start(), matcher.end());
					}
				}
			}
			reader.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return hardInfo;
	}
	
	private boolean interrupt;

	/**
	 * 解压一个压缩文档 到指定位置
	 * 
	 * @param zipFileString
	 *            压缩包的名字
	 * @param outPathString
	 *            指定的路径
	 * @throws Exception
	 */
	public void UnZipFolder(String zipFileString, String outPathString) throws Exception {
		ZipInputStream inZip = new ZipInputStream(new FileInputStream(zipFileString));
		ZipEntry zipEntry;
		String szName = "";

		while ((zipEntry = inZip.getNextEntry()) != null) {
			szName = zipEntry.getName();
//			System.out.println("UnZipFolder----"+szName);
			if (zipEntry.isDirectory()) {
				// get the folder name of the widget
				szName = szName.substring(0, szName.length() - 1);
				File folder = new File(outPathString, szName);
				folder.mkdirs();
			} else {
				File file = new File(outPathString, szName);
				if (!file.getParentFile().exists())
					file.getParentFile().mkdirs();
				file.createNewFile();
				FileOutputStream out = new FileOutputStream(file);
				int len;
				byte[] buffer = new byte[1024];
				while ((len = inZip.read(buffer)) != -1) {
//					System.out.println(interrupt);
					if (interrupt) {
						System.out.println("Thread sleep 1000");
						Thread.sleep(1000);// 睡眠
					}
					out.write(buffer, 0, len);
					out.flush();
				}
				out.close();
			}
		}// end of while
		inZip.close();
	}// end of func

	/**
	 * 删除文件夹
	 * 
	 * @param path
	 */
	public static void delDir(String path) {
		File dir = new File(path);
		if (dir.exists()) {
			File[] tmp = dir.listFiles();
			for (int i = 0; i < tmp.length; i++) {
				if (tmp[i].isDirectory()) {
					delDir(path + "/" + tmp[i].getName());
				} else {
					tmp[i].delete();
				}
			}
			dir.delete();
		}
	}

	// -----------------------------------------------------------------------
	/**
	 * Copies bytes from the URL <code>source</code> to a file
	 * <code>destination</code>. The directories up to <code>destination</code>
	 * will be created if they don't already exist. <code>destination</code>
	 * will be overwritten if it already exists.
	 * 
	 * @param source
	 *            A <code>URL</code> to copy bytes from.
	 * @param destination
	 *            A non-directory <code>File</code> to write bytes to (possibly
	 *            overwriting).
	 * 
	 * @throws IOException
	 *             if
	 *             <ul>
	 *             <li><code>source</code> URL cannot be opened</li>
	 *             <li><code>destination</code> cannot be written to</li>
	 *             <li>an IO error occurs during copying</li>
	 *             </ul>
	 */
	public static void copyURLToFile(URL source, File destination) throws Exception {
		// does destination directory exist ?
		if (destination.getParentFile() != null && !destination.getParentFile().exists()) {
			destination.getParentFile().mkdirs();
		}
		// make sure we can write to destination
		if (destination.exists() && !destination.canWrite()) {
			String message = "Unable to open file " + destination + " for writing.";
			throw new IOException(message);
		}
		InputStream input = null;
		try {
			input = source.openStream();
			FileOutputStream output = new FileOutputStream(destination);
			try {
				copy(input, output);
			} catch (Exception e) {
				throw e;
			} finally {
				closeQuietly(output);
			}
		} catch (Exception e) {
			throw e;
		} finally {
			closeQuietly(input);
		}
	}

	/**
	 * The default buffer size to use.
	 */
	private static final int DEFAULT_BUFFER_SIZE = 1024 * 4;

	// copy from InputStream
	// -----------------------------------------------------------------------
	/**
	 * Copy bytes from an <code>InputStream</code> to an
	 * <code>OutputStream</code>.
	 * <p>
	 * This method buffers the input internally, so there is no need to use a
	 * <code>BufferedInputStream</code>.
	 * 
	 * @param input
	 *            the <code>InputStream</code> to read from
	 * @param output
	 *            the <code>OutputStream</code> to write to
	 * @return the number of bytes copied
	 * @throws NullPointerException
	 *             if the input or output is null
	 * @throws IOException
	 *             if an I/O error occurs
	 * @since Commons IO 1.1
	 */
	public static int copy(InputStream input, OutputStream output) throws IOException {
		byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
		int count = 0;
		int n = 0;
		while (-1 != (n = input.read(buffer))) {
			output.write(buffer, 0, n);
			count += n;
		}
		return count;
	}

	/**
	 * Unconditionally close an <code>OutputStream</code>.
	 * <p>
	 * Equivalent to {@link OutputStream#close()}, except any exceptions will be
	 * ignored. This is typically used in finally blocks.
	 * 
	 * @param output
	 *            the OutputStream to close, may be null or already closed
	 */
	public static void closeQuietly(OutputStream output) {
		try {
			if (output != null) {
				output.close();
			}
		} catch (IOException ioe) {
			// ignore
		}
	}

	/**
	 * Unconditionally close an <code>InputStream</code>.
	 * <p>
	 * Equivalent to {@link InputStream#close()}, except any exceptions will be
	 * ignored. This is typically used in finally blocks.
	 * 
	 * @param input
	 *            the InputStream to close, may be null or already closed
	 */
	public static void closeQuietly(InputStream input) {
		try {
			if (input != null) {
				input.close();
			}
		} catch (IOException ioe) {
			ioe.printStackTrace();
		}
	}

}

class HardInfo {
	String machine;
	String sysVersion;
}

class SyssoftInfo {
	String versionId;
	String publishTime;
	String MD5;
}

class SimpleObjectAdapter extends BaseAdapter {
	private List<ListItem> list;

	private Context context;

	private String resource;

	public SimpleObjectAdapter(Context context, List<ListItem> list, String resouce) {
		this.context = context;
		this.list = list;
		this.resource = resouce;
	}

	@Override
	public int getCount() {
		return list.size();
	}

	@Override
	public ListItem getItem(int position) {
		return list.get(position);
	}

	@Override
	public long getItemId(int position) {
		return position;
	}

	@Override
	public View getView(int position, View convertView, ViewGroup parent) {
		return list.get(position).matchView(context, convertView, parent, resource);
	}
}

abstract class ListItem {
	private Class<?> rClass;

	public ListItem(Class<?> rClass) {
		this.rClass = rClass;

	}

	public abstract void doAction();

	public View matchView(Context context, View convertView, ViewGroup parent, String resource) {
		View v = null;
		try {
			if (convertView == null) {
				Field field = this.getClass().getDeclaredField("title");
				field.setAccessible(true);
				String title = (String) field.get(this);
				LinearLayout layout = new LinearLayout(context);
				Button button = new Button(context);
				LayoutParams layoutParams = new LayoutParams(LayoutParams.WRAP_CONTENT,
						LayoutParams.WRAP_CONTENT);
				button.setLayoutParams(layoutParams);
				button.setText(title);
				button.setOnClickListener(new View.OnClickListener() {
					@Override
					public void onClick(View v) {
						doAction();
					}
				});
				layout.addView(button);
				v = layout;
			} else {
				v = convertView;
			}
			v.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					doAction();
				}
			});
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		// Class<?> layoutClass = null;
		// Class<?> idClass = null;
		// try {
		// if (convertView == null) {
		// LayoutInflater mInflater = (LayoutInflater) context
		// .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
		// Class<?>[] rSubClasses = rClass.getClasses();
		// for (int i = 0; i < rSubClasses.length; i++) {
		// if (rSubClasses[i].getName().endsWith("layout")) {
		// layoutClass = rSubClasses[i];
		// } else if (rSubClasses[i].getName().endsWith("id")) {
		// idClass = rSubClasses[i];
		// }
		// }
		// v = mInflater.inflate(layoutClass.getField(resource).getInt(null),
		// parent, false);
		// } else {
		// v = convertView;
		// }
		//
		// Field[] objectFields = this.getClass().getDeclaredFields();
		// AccessibleObject.setAccessible(objectFields, true);
		// for (int i = 0; i < objectFields.length; i++) {
		// try {
		// View elementView = v.findViewById(idClass.getField(
		// resource + "_" + objectFields[i].getName()).getInt(null));
		// if (elementView instanceof TextView) {
		// TextView textView = (TextView) elementView;
		// textView.setText((String) objectFields[i].get(this));
		// }
		// elementView.setOnClickListener(new View.OnClickListener() {
		// @Override
		// public void onClick(View v) {
		// doAction();
		// }
		// });
		// } catch (Exception e) {
		// }
		// }
		//
		// v.setOnClickListener(new View.OnClickListener() {
		// @Override
		// public void onClick(View v) {
		// doAction();
		// }
		// });
		// } catch (Exception e) {
		// // TODO Auto-generated catch block
		// e.printStackTrace();
		// }
		return v;
	}
}

class DataDownloadThread extends DataTransfer {

	private static final long serialVersionUID = -7222521441328829962L;
	private URL srcURL;
	private File dest;
	private int threadCount;
	private String algorithm, checksum, verifyStatus;
	/**
	 * @deprecated 代理IP,暂不使用
	 */
	private SocketAddress proxyAddr;
	private boolean done;
	/**
	 * 数据下载线程
	 */
	private DownloadThread[] threads;
	transient private int connected, finished, paused;
	/**
	 * 是否支持断点续传(此属性由服务器决定)
	 */
	private boolean resumeSupported;

	transient private boolean destroyed;
	transient private RandomAccessFile randomDest;

	transient private int startByte;

	public DataDownloadThread(int clientId, String actionUrl) {
		super(clientId, actionUrl);
	}

	/**
	 * Constructor accepting all the necessary parameters.
	 * 
	 * @note 此处参数url可以改为String类型
	 */
	public DataDownloadThread(int clientId, String actionUrl, int threadCount, String destFile) {
		this(clientId, actionUrl);
		if (threadCount > 0) {
			this.threadCount = threadCount;
		}
		this.dest = new File(destFile);
		if (!dest.getParentFile().exists()) {
			dest.getParentFile().mkdirs();
		}
		this.resumeSupported = true;
	}

	/**
	 * Sets up the proxy for the download from the given proxy host and port.
	 * 
	 * @param host
	 *            The host which runs the proxy server.
	 * @param port
	 *            Port on the proxy server which is used to run the proxy.
	 */
	public void setProxy(String host, int port) {
		proxyAddr = new InetSocketAddress(host, port);
	}

	/**
	 * Implementation of the run() method of Runnable interface. It performs a
	 * dummy connection to extract URL headers. It also checks for HTTP response
	 * code. It retries even if the connection fails the first time.
	 * 
	 * For more info on HTTP response code, see <a
	 * href="http://en.wikipedia.org/wiki/List_of_HTTP_status_codes"> List of
	 * HTTP status code</a>.
	 */
	public void run() {
		running = true;
		updateTransferStatus(Event.TRANSFER_STATUS_RUNNING);
		URLConnection urlConn;
		int response = 0;
		try {
			// GlobalData.model.setDownloadStatus(srcURL, "Connecting...");

			if (proxyAddr != null) {
				Proxy proxy = new Proxy(Proxy.Type.HTTP, proxyAddr);
				urlConn = getURL().openConnection(proxy);
			} else {
				urlConn = getURL().openConnection();
			}
			urlConn.setRequestProperty("Range", "bytes=0-");

			// special paramters for SEKEDE services
			this.checksum = ((HttpURLConnection) urlConn).getHeaderField("MD5");

			// getHeaderFields(urlConn.getHeaderFields());

			response = ((HttpURLConnection) urlConn).getResponseCode();

			printf("download response code: " + response + " md5: " + checksum);

			resumeSupported = (response == 206);
			length = ((HttpURLConnection) urlConn).getContentLength();
			String status, size;

			if (length < 0 || (response != 200 && response != 206)) {
				reconnectionTimes = -1;
				throw new java.net.SocketException("Empty HTTP response!");
			} else {
				status = "Spawning...";
				size = toSizeString(length);
			}

			if (!resumeSupported) {
				threadCount = 1;
			}

			if (verifyStatus == null) {
				verifyStatus = isVerifiable() ? "Pending" : "NA";
			}

			if (status.equals("Failed")) {

				threads = null;
				return;
			}
			if (threads == null) {
				allocateThreads();
			}
			beginDownload();
		} catch (Exception e) {
			e.printStackTrace();
			running = false;
			System.out.println(" Exception reconnectionTimes: " + reconnectionTimes);
			if (reconnectionTimes > 0) {
				try {
					Thread.sleep(1000);
					resumeDownload(); // Retry connecting
				} catch (Exception e2) {
					// TODO: handle exception
				}
			} else {
				updateTransferStatus(Event.TRANSFER_STATUS_FAILED);
				if (response == 0 || response == 200 || response == 206) {
					throwException(e);
				} else {
					throwException(response);
				}
				System.gc();
			}
		}
	}

	/**
	 * Allocates the DownloadThread objects required to perform the
	 * multi-threaded downloads.
	 */
	private void allocateThreads() {
		threads = new DownloadThread[threadCount];
		int partSize = (int) (length / threadCount);
		int start, i;
		for (i = 0; i < threadCount - 1; i++) {
			start = partSize * i;
			threads[i] = new DownloadThread(getURL(), proxyAddr, start, start + partSize - 1);
		}
		threads[i] = new DownloadThread(getURL(), proxyAddr, partSize * i, (int) (length - 1));
	}

	/**
	 * Starts the download threads and the progress updates on the download
	 * monitor.
	 * 
	 * @throws java.io.IOException
	 *             If error occurs while opening the destination file.
	 */
	private void beginDownload() throws IOException {
		randomDest = new RandomAccessFile(dest, "rw");
		paused = 0;
		startTime = new Date();
		calculateCompleted();
		startByte = (int) completed;
		for (int i = 0; i < threadCount; i++) {
			threads[i].setManager(this);
			threads[i].setDest(randomDest);
			threads[i].startThread();
		}
		beginProgressUpdates();
	}

	/**
	 * Each DownloadThread object invokes this method when the connection is
	 * established.
	 */
	synchronized void addConnected() {
		connected++;
		updateStatus();
	}

	/**
	 * Each DownloadThread object invokes this method when the connection is
	 * disconnected for any reason.
	 */
	synchronized void addDisconnected() {
		connected--;
		updateStatus();
	}

	/**
	 * Each DownloadThread object invokes this method when the thread is paused.
	 * If all threads have been paused, it closes the destination file stream
	 * and displays the OSD.
	 */
	synchronized void addPaused() {
		connected--;
		paused++;
		updateStatus();
		if (paused == threadCount) {
			if (!destroyed) {
				// GlobalData.model.setDownloadStatus(srcURL, "Paused");
				// osdWin.showOSD(dest.getName(), "Paused", verifyStatus);
			}
			connected = finished = 0;
			running = false;
			// updateTransferStatus(TRANSFER_STATUS_PAUSED);
			try {
				randomDest.close();
				if (destroyed) {
					dest.delete();
				}
			} catch (IOException e) {
				e.printStackTrace();
				return;
			}
			System.gc();
		}
	}

	/**
	 * Terminates the download after pausing all the threads. The DownloadThread
	 * array is also removed.
	 */
	public synchronized void terminateDownload() {
		destroyed = true;
		updateTransferStatus(Event.TRANSFER_STATUS_STOPED);
		if (threads != null) {
			pauseDownload();
		}

		if (!done && dest.exists()) {
			dest.delete();
		}
		running = false;
	}

	/**
	 * Each DownloadThread object invokes this method when the thread is
	 * finished. If all threads have been finished, it closes the destination
	 * file stream and displays the OSD. Optionally, it may also start the
	 * checksum verification.
	 */
	synchronized void addFinished() {
		connected--;
		finished++;
		updateProgress();
		// updateStatus();
		if (finished == threadCount) {
			threads = null;
			running = false;
			updateTransferStatus(Event.TRANSFER_STATUS_COMPLETED);
			done = true;
			resumeSupported = true; // Avoid confirmation during exit
			try {
				randomDest.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
			if (verifyStatus.equals("Pending")) {
				beginVerification();
			}

			if (verifyStatus.equals("NA")) {
				// osdWin.showOSD(dest.getName(), "Completed", verifyStatus);
			}
			System.gc();
		}
	}

	/**
	 * Updates the status of the file download. It shows the total number of
	 * connected and completed threads.
	 */
	private void updateStatus() {
		if (finished == threadCount) {
			// new File(this.getSavedFilePath() +
			// Constants.CONFIG_SUFFIX).deleteOnExit();
			try {
				if (!TextUtils.isEmpty(this.checksum)) {
					if (!MD5Util.getFileMD5String(this.dest).equals(this.checksum)) {
						throwException(ERROR_CODE_AUTHENTICATION_FIALED);
					}
				}
				updateTransferStatus(Event.TRANSFER_STATUS_COMPLETED);
			} catch (Exception e) {
				// TODO: handle exception
				e.printStackTrace();
			}

			// GlobalData.model.setDownloadStatus(srcURL, "Completed");
		} else {
			// GlobalData.model.setDownloadStatus(srcURL, connected +
			// " Connected"
			// + ", " + finished + " Completed");
		}
	}

	/**
	 * Invoked when the user pauses the download. It pauses each individual
	 * thread.
	 */
	public synchronized void pauseDownload() {
		if (running) {
			for (DownloadThread t : threads) {
				t.pauseThread();
			}
		}
	}

	@Override
	public void pauseTransfer() {
		try {
			updateTransferStatus(resumeSupported ? Event.TRANSFER_STATUS_PAUSED
					: Event.TRANSFER_STATUS_STOPED);
			if (!resumeSupported) {
				new Thread() {
					public void run() {
						interruptTransfer();
					};
				}.start();
			} else {
				pauseDownload();
			}
		} catch (Exception e) {
			// TODO: handle exception
		}
	}

	/**
	 * It resumes a paused download when the user resumes it or when JDownZ is
	 * started.
	 */
	public synchronized void resumeDownload() {
		if (!running) {
			if (done) {
				calculateCompleted();
				finished = threadCount;
				length = completed;
				resumeSupported = true;
				updateStatus();
				// GlobalData.model.setSize(srcURL, toSizeString(length));
				updateProgress();
				if (verifyStatus.equals("Pending")) {
					beginVerification();
				}
			} else {
				destroyed = false;
				Thread t = new Thread(this);
				t.start();
			}
			reconnectionTimes--;
		}
	}

	/**
	 * It calculates the total number of bytes which has been downloaded so far.
	 */
	private void calculateCompleted() {
		if (threads != null) {
			completed = 0;
			for (DownloadThread t : threads) {
				completed += t.getCompleted();
			}
		}
	}

	/**
	 * It returns the URL from which is data is being downloaded.
	 * 
	 * @return The source URL from which data is being downloaded.
	 */
	public URL getURL() {
		if (srcURL == null) {
			try {
				srcURL = new URL(actionUrl);
			} catch (MalformedURLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		return srcURL;
	}

	/**
	 * Returns the destination file to which the downloaded data is being
	 * written.
	 * 
	 * @return Return Destination file used for the download.
	 */
	public File getDestination() {
		return dest;
	}

	/**
	 * Checks whether checksum verification of the downloaded file is required
	 * or not.
	 * 
	 * @return true - Checksum verification is required. false - Checksum
	 *         verification is not required.
	 */
	public boolean isVerifiable() {
		return (algorithm != null);
	}

	/**
	 * Checks whether the resumption of this download is supported or not.
	 * 
	 * @return true - The download can be resumed. false - The download cannot
	 *         be resumed.
	 */
	public boolean isResumeSupported() {
		return resumeSupported;
	}

	/**
	 * Converts the given number of bytes into an appropriate String form
	 * (Bytes, KB, MB or GB).
	 * 
	 * @param bytes
	 *            Number of bytes to be converted.
	 * 
	 * @return String representing the bytes in appropriate unit.
	 */
	private String toSizeString(long bytes) {
		String unit = " Bytes";
		float value = bytes;
		if (value >= 1024) {
			value = value / 1024;
			unit = " KB";
		}
		if (value >= 1024) {
			value = value / 1024;
			unit = " MB";
		}
		if (value >= 1024) {
			value = value / 1024;
			unit = " GB";
		}
		return String.format("%.2f %s", value, unit);
	}

	/**
	 * Invokes the <code>updateProgress()</code> method every second as long the
	 * download runs.
	 */
	private void beginProgressUpdates() {
		try {
			while (running) {
				if (running) {
					updateProgress();
				}
				Thread.sleep(2000);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Calculate the total number of bytes downloaded and updates the progress
	 * appropriately.
	 */
	private synchronized void updateProgress() {
		/*
		 * float kbytes = 0; int secs = 1; if (startTime != null) {
		 * calculateCompleted(); kbytes = (completed - startByte) / 1024; secs =
		 * (int) ((new Date().getTime() - startTime.getTime()) / 1000);
		 * startByte = (int) completed; startTime = new Date(); } float speed;
		 * if (secs == 0) { speed = 0; } else { speed = kbytes / secs; }
		 */

		// float currProgress = getCurrentProgress();
		// String timeLeft = toTimeString((long) (((length - completed) / 1024)
		// / speed));

		// taskProgresStatus(currProgress, speed, timeLeft);

		calculateCompleted();
		if (statusListener != null) {
			this.statusListener.handleProgress(actionUrl, getCurrentProgress());
		}
		;
	}

	/**
	 * get current downloads progress
	 * 
	 * @return
	 */
	public float getCurrentProgress() {
		if (length == 0) {
			return 0.f;
		}
		return (float) completed / length * 100;
	}

	/**
	 * Performs checksum generation and verification. Displays the OSD
	 * appropriately.
	 */
	private void beginVerification() {
		try {
			if (MD5Util.getFileMD5String(this.dest).equals(this.checksum)) {
				verifyStatus = "Success";
			} else {
				verifyStatus = "Failed";
			}
		} catch (Exception e) {
			if (!e.getMessage().equals("Stream closed")) {
				e.printStackTrace();
			}
		}
	}

	/**
	 * Checks whether the download has been completed or not.
	 * 
	 * @return true - The download is complete. false - The download is not
	 *         complete.
	 */
	synchronized public boolean isComplete() {
		return finished == threadCount;
	}

	/**
	 * 返回要下载的文件路径
	 * 
	 * @return
	 */
	public String getSavedFilePath() {
		if (dest != null) {
			return this.dest.getAbsolutePath();
		}
		return null;
	}

	@Override
	public float getProgress() {
		return getCurrentProgress();
	}

	@Override
	public void interruptTransfer() {

		terminateDownload();
		System.gc();// TODO 需验证
	}

}

abstract class DataTransfer implements Runnable, Serializable {

	private static final long serialVersionUID = 6585995110761436428L;

	/**
	 * data transfer error code <b>Unkown exception</b>
	 */
	public final static int ERROR_CODE_UNKOWN = 0x7f020;

	/**
	 * data transfer error code <b>Indirect URL</b>
	 */
	public final static int ERROR_CODE_INDIRECT_URL = ERROR_CODE_UNKOWN + 1;

	/**
	 * data transfer error code <b>Network invalid</b>
	 */
	public final static int ERROR_CODE_NETWORK_INVALID = ERROR_CODE_UNKOWN + 2;

	/**
	 * data transfer error code <b>Local file not found</b>
	 */
	public final static int ERROR_CODE_IOEXCEPTION = ERROR_CODE_UNKOWN + 3;

	/**
	 * data transfer error code <b>Authentication failed</b>
	 */
	public final static int ERROR_CODE_AUTHENTICATION_FIALED = ERROR_CODE_UNKOWN + 4;

	/**
	 * 网络传输状态
	 */
	protected int transfer_status = Event.TRANSFER_STATUS_STOPED;

	/**
	 * 重试次数
	 */
	transient int reconnectionTimes = 10;

	/**
	 * 是否正在运行
	 */
	transient boolean running = false;

	/**
	 * 服务端产生的分配给客户端的ID号
	 */
	private int clientId;

	/**
	 * 要传输数据的URL
	 */
	protected String actionUrl;

	/**
	 * 传输完的长度
	 */
	protected long completed;

	/**
	 * 传输的文件长度(byte)
	 */
	transient long length;

	/**
	 * 任务开始时间(用于计算剩余时间)
	 */
	transient Date startTime;

	/**
	 * 状态监听器
	 */
	protected transient TransferListener statusListener;

	public DataTransfer() {
		// TODO Auto-generated constructor stub
	}

	public DataTransfer(int clientId, String actionUrl) {
		this.clientId = clientId;
		this.actionUrl = actionUrl;
	}

	/**
	 * 返回文件传输进度
	 * 
	 * @return
	 */
	public abstract float getProgress();

	/**
	 * 中断传输任务
	 */
	public abstract void interruptTransfer();

	/**
	 * 暂停传输任务
	 */
	public abstract void pauseTransfer();

	/**
	 * 返回文件传输状态 *
	 * <ul>
	 * <li><b>101</b> 传输中
	 * <li><b>102</b> 已暂停(下载有效)
	 * <li><b>103</b> 已停止
	 * <li><b>104</b> 已完成
	 * </ul>
	 * 
	 * @return
	 */
	public int getTransferStatus() {
		return this.transfer_status;
	}

	/**
	 * 得到返回代码
	 * 
	 * @param response
	 * @return
	 * @throws IOException
	 */
	int getResponseCode(HttpResponse response) throws IOException {
		if (HttpStatus.SC_OK == response.getStatusLine().getStatusCode()) {

			HttpEntity responseEntity = response.getEntity();

			if (responseEntity != null) {
				responseEntity.consumeContent();
			}
		}

		return response.getStatusLine().getStatusCode();
	}

	/**
	 * 得到返回的HTML
	 * 
	 * @param actionUrl
	 * @param nameValuePairs
	 * @return
	 */
	String getResponseHTML(HttpResponse response) {
		try {

			if (HttpStatus.SC_OK == response.getStatusLine().getStatusCode()) {
				HttpEntity responseEntity = response.getEntity();
				// 显示内容
				if (responseEntity != null) {
					return EntityUtils.toString(responseEntity);
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw new RuntimeException("Response code error!");
		}
		return null;
	}

	/**
	 * Converts the given number of seconds into hours, minutes and seconds.
	 * 
	 * @param secs
	 *            Total number of seconds.
	 * 
	 * @return A string representation of the seconds given.
	 */
	static String toTimeString(long secs) {
		String result = "";
		result += (secs / 3600) + "h ";
		secs %= 3600;
		result += (secs / 60) + "m ";
		secs %= 60;
		result += secs + "s";
		return result;
	}

	/**
	 * 抛出异常代码到客户端
	 * 
	 * TODO 此处code 需要根据异常信息重新指定
	 * 
	 * @param errorCode
	 */
	void throwException(Exception e) {

		int errorCode = ERROR_CODE_UNKOWN;

		if (e instanceof java.io.FileNotFoundException) {
			errorCode = ERROR_CODE_IOEXCEPTION;
		} else if (e instanceof java.net.SocketException) {
			errorCode = ERROR_CODE_NETWORK_INVALID;
		} else if (e instanceof java.net.UnknownHostException) {
			errorCode = ERROR_CODE_NETWORK_INVALID;
		} else if (e instanceof java.io.IOException) {
			errorCode = ERROR_CODE_IOEXCEPTION;
		}

		throwException(errorCode);
	}

	/**
	 * 抛出数据传输异常代码到客户端 *
	 * <ul>
	 * <li><b>0x7f020</b> Unkown exception
	 * <li><b>0x7f020+1</b> Indirect URL
	 * <li><b>0x7f020+2</b> Network invalid
	 * <li><b>0x7f020+3</b> Local file not found
	 * <li><b>0x7f020 + 4</b> Authentication failed
	 * <li><b>4xx</b> Request errors
	 * <li><b>5xx</b> Server errors
	 * </ul>
	 * 
	 * @param errorCode
	 */
	void throwException(int errorCode) {
		printf(" throw exception :" + errorCode);
		try {
			// if (clientListener != null) {
			// clientListener.throwException(clientId, errorCode);
			// }
		} catch (Exception e1) {
			// do nothing
		}
	}

	/**
	 * 传输状态Event
	 * 
	 */
	class TransferEvent implements Event {

		private int status;

		public TransferEvent(int status) {
			this.status = status;
		}

		@Override
		public int getTransferStatus() {
			// TODO Auto-generated method stub
			return status;
		}

		@Override
		public String getURL() {
			// TODO Auto-generated method stub
			return actionUrl;
		}

		@Override
		public float getProgress() {
			return -1;
		}
	}

	/**
	 * 更新传输状态
	 * 
	 * @param status_code
	 */
	public synchronized void updateTransferStatus(int status_code) {
		if (this.transfer_status != status_code) {
			this.transfer_status = status_code;
			if (this.statusListener != null) {
				Event event = new TransferEvent(transfer_status);// 触发了某事件
				this.statusListener.handleEvent(event);
			}
		}
	}

	/**
	 * 得到客户端ID
	 * 
	 * @return
	 */
	public int getClientId() {
		return clientId;
	}

	private static HttpClient httpClient;

	protected HttpClient getHttpClient() {
		if (httpClient == null) {
			httpClient = createHttpClient();
		}
		return httpClient;
	}

	/**
	 * Create Threads safe client
	 * 
	 * @return
	 */
	private static HttpClient createHttpClient() {
		HttpParams params = new BasicHttpParams();
		HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
		HttpProtocolParams.setContentCharset(params, HTTP.DEFAULT_CONTENT_CHARSET);
		HttpProtocolParams.setUseExpectContinue(params, true);

		SchemeRegistry schReg = new SchemeRegistry();
		schReg.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
		schReg.register(new Scheme("https", PlainSocketFactory.getSocketFactory(), 443));
		ClientConnectionManager conMgr = new ThreadSafeClientConnManager(params, schReg);

		return new DefaultHttpClient(conMgr, params);
	}

	protected void shutdownHttpClient() {
		if (httpClient != null && httpClient.getConnectionManager() != null) {
			httpClient.getConnectionManager().shutdown();
			httpClient = null;
		}
	}

	public long getCompleted() {
		return completed;
	}

	public String getActionUrl() {
		return actionUrl;
	}

	public boolean isRunning() {
		return running;
	}

	/**
	 * 设置状态监听器
	 */
	public void setStatusListener(TransferListener statusListener) {
		this.statusListener = statusListener;
	}

	/**
	 * 判断是否有监听器
	 * 
	 * @return
	 */
	public boolean hasStatusListener() {
		return this.statusListener == null ? false : true;
	}

	/**
	 * 重置配置参数
	 */
	public void resetConfiguration() {
		reconnectionTimes = 3;
	}

	protected void printf(String str) {

		Log.w("DataTransfer", "#####: " + str + "------");

	}
}

class DownloadManager {

	private static DownloadManager instance;

	private final static Object LOCK = new Object();

	public static DownloadManager getInstance() {
		synchronized (LOCK) {
			if (instance == null) {
				instance = new DownloadManager();
			}
			return instance;
		}
	}

	/**
	 * 存储下载任务
	 */
	private static Map<String, DataTransfer> transferMap = new HashMap<String, DataTransfer>();

	/**
	 * 建立下载任务并下载文件
	 * 
	 * @param urlStr
	 *            URL路径
	 * @param threadNum
	 *            线程数(1-10,默认为1，如下载比较小的文件，建议设置成1)
	 * @param fileName
	 *            文件另存路径
	 * @return false 建立下载任务失败
	 * @throws RemoteException
	 */
	public static boolean createDownloadTask(String urlStr, int threadNum, String fileName) throws Exception {
		// TODO Auto-generated method stub
		try {

			DataTransfer dataTransfer = new DataDownloadThread(0, urlStr, threadNum, fileName);
			// System.out.println(" createDownloadTask: " +
			// dataTransfer.getActionUrl() );
			if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
				Thread t = new Thread(dataTransfer);
				t.start();
				return true;
			}
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			throw new Exception("Create download task failed, error message :" + e.getMessage());
		}

		return false;
	}

	/**
	 * 建立下载任务并下载文件
	 * 
	 * @param urlStr
	 *            URL路径
	 * @param threadNum
	 *            线程数(1-10,默认为1，如下载比较小的文件，建议设置成1)
	 * @param fileName
	 *            文件另存路径
	 * @param transferListener
	 *            数据下载状态监听器
	 * 
	 * @return false 建立下载任务失败
	 * @throws RemoteException
	 */
	public static boolean createDownloadTask(String urlStr, int threadNum, String fileName,
			TransferListener transferListener) throws Exception {
		// TODO Auto-generated method stub
		try {
			DataTransfer dataTransfer = transferMap.get(urlStr);
			// System.out.println(" createDownloadTask: " + urlStr );
			if (dataTransfer == null || !dataTransfer.isRunning()) {
				dataTransfer = new DataDownloadThread(0, urlStr, threadNum, fileName);
				if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
					Thread t = new Thread(dataTransfer);
					t.start();
				}
				transferMap.put(urlStr, dataTransfer);
			}

			dataTransfer.setStatusListener(transferListener);
			return true;
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			throw new Exception("Create download task failed, error message :" + e.getMessage());
		}
	}

	/**
	 * 中断下载任务，不适用于<code>simpleDownload</code>函数添加的下载任务.
	 * 
	 * @param urlStr
	 */
	public static void interruptDownloadTask(String urlStr) {
		try {
			DataTransfer dataTransfer = transferMap.get(urlStr);
			if (dataTransfer != null) {
				dataTransfer.interruptTransfer();
				transferMap.remove(urlStr);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}

	}

}

class DownloadThread implements Runnable, Serializable {
	private URL src;
	private long start, end, completed;
	private boolean canContinue;
	private SocketAddress proxyAddr;

	transient private DataDownloadThread manager;
	transient private RandomAccessFile dest;
	transient private BufferedInputStream bin;
	transient private Thread t;
	// 连接失败的次数
	private int connectionFailedCount = 20;

	/**
	 * Initializes the DownloadThread object with appropriate data.
	 * 
	 * @param url
	 *            The URL from which data is to be downloaded.
	 * @param proxyAddr
	 *            The address of the proxy server to be used.
	 * @param start
	 *            The starting byte from which the download must begin.
	 * @param end
	 *            The byte where the download must end.
	 */
	public DownloadThread(URL url, SocketAddress proxyAddr, long start, long end) {
		src = url;
		this.start = start;
		this.end = end;
		this.proxyAddr = proxyAddr;
		// System.out.println(" DownloadThread,start: " + start + " end: " +
		// end);
	}

	/**
	 * Sets the <code>DownloadTemp</code> which must be used to update the
	 * status.
	 * 
	 * @param download
	 *            The <code>DownloadTemp</code> object which managesthis thread.
	 */
	public void setManager(DataDownloadThread download) {
		manager = download;
	}

	/**
	 * Sets the <code>RandomAccessFile</code> to be used to save the downloaded
	 * data.
	 * 
	 * @param dest
	 *            The destination file.
	 */
	public void setDest(RandomAccessFile dest) {
		this.dest = dest;
	}

	/**
	 * Handles the actual download of data from the URL specified.
	 */
	public void run() {
		boolean connected = false;
		URLConnection conn = null;
		if (completed == (end - start + 1)) {
			manager.addConnected(); // Simulate connection before completion
			manager.addFinished();
			return;
		}
		try {
			if (proxyAddr != null)
				conn = src.openConnection(new Proxy(Proxy.Type.HTTP, proxyAddr));
			else
				conn = src.openConnection();

			if (manager.isResumeSupported()) {
				// conn.setConnectTimeout(10000);
				conn.setConnectTimeout(10000);
			} else {
				completed = 0; // A non-resumable download is resumed
			}
			conn.setRequestProperty("Range", "bytes=" + (start + completed) + "-" + end);

			if (manager.isResumeSupported()) {
				// conn.setReadTimeout(10000);
				conn.setReadTimeout(3000);
			}

			if (!canContinue) {
				manager.addPaused();
				return;
			}
			int response = ((HttpURLConnection) conn).getResponseCode();
			if (response != 200 && response != 206) {
				if (canContinue) {
					startThread();
				}
				return;
			}
			bin = new BufferedInputStream(conn.getInputStream());
			manager.addConnected();
			connected = true;
			byte[] data = new byte[1024];
			int readLen;
			while (canContinue && (readLen = bin.read(data)) != -1) {
				synchronized (dest) {
					dest.seek(start + completed);
					dest.write(data, 0, readLen);
					completed += readLen;
				}
			}

			if (canContinue) {
				if (completed == (end - start + 1)) {
					manager.addFinished();
				} else {
					manager.addDisconnected();
					startThread();
					return;
				}
			} else {
				manager.addPaused();
			}

			bin.close();
		} catch (SocketTimeoutException e) {
			if (canContinue) {
				if (connected) {
					manager.addDisconnected();
				}
				startThread();
			} else {
				if (!connected) {
					manager.addConnected(); // Simulate connection
				}
				manager.addPaused();
			}
			e.printStackTrace();
		} catch (IOException e) {
			connectionFailedCount--;
			// connectionFailedCount <
			// Constants.CONNECTION_NETWORK_FAILED_COUNT:如果连接失败次数小于指定的次数,则继续连接下载,否则退出下载
			if (canContinue && connectionFailedCount > 0) {
				if (connected) {
					manager.addDisconnected();
				}
				startThread();
			} else {
				if (!connected) {
					manager.addConnected(); // Simulate connection
				}
				manager.addPaused();
			}
			e.printStackTrace();
		}
	}

	/**
	 * Starts the download thread.
	 */
	public void startThread() {
		try {
			if (bin != null) {
				bin.close();
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
		canContinue = true;
		t = new Thread(this);
		t.start();
	}

	/**
	 * Pauses the download thread and waits till it is properly paused.
	 */
	public void pauseThread() {
		if (!canContinue) {
			manager.addConnected();
			manager.addPaused();
			return;
		}

		canContinue = false;
		if (completed == (end - start + 1)) {
			manager.addConnected(); // Simulate connection before pause
			manager.addPaused();
		}
	}

	/**
	 * Returns the total number of bytes downloaded so far by the thread.
	 * 
	 * @return The number of bytes downloaded.
	 */
	public long getCompleted() {
		return completed;
	}
}

interface Event {

	// data transfer status
	/**
	 * 网络传输状态: 传输中
	 */
	final static int TRANSFER_STATUS_RUNNING = 101;

	/**
	 * 网络传输状态: 已暂停(对于文件下载才有效)
	 */
	final static int TRANSFER_STATUS_PAUSED = 102;

	/**
	 * 网络传输状态: 已停止
	 */
	final static int TRANSFER_STATUS_STOPED = 103;

	/**
	 * 网络传输状态: 已完成
	 */
	final static int TRANSFER_STATUS_COMPLETED = 104;

	/**
	 * 网络传输状态: 传输失败
	 */
	final static int TRANSFER_STATUS_FAILED = 105;

	/**
	 * 网络传输状态: 未知
	 */
	final static int TRANSFER_STATUS_UNKNOW = -1;

	// data transfer status end

	/**
	 * 获取下载进度值,范围(0.f-100.f)
	 * 
	 * @return
	 */
	float getProgress();

	/**
	 * 获取下载状态标示，为以下类型值之一:<br/>
	 * <ul>
	 * <li>{@link #TRANSFER_STATUS_COMPLETED}
	 * <li>{@link #TRANSFER_STATUS_FAILED}
	 * <li>{@link #TRANSFER_STATUS_PAUSED}
	 * <li>{@link #TRANSFER_STATUS_RUNNING}
	 * <li>{@link #TRANSFER_STATUS_STOPED}
	 * <li>{@link #TRANSFER_STATUS_UNKNOW}
	 * </ul>
	 * 
	 * @return
	 */
	int getTransferStatus();

	/**
	 * 获取当前下载任务的URL
	 * 
	 * @return
	 */
	String getURL();
}

interface TransferListener {

	/**
	 * 数据传输状态改变监听器
	 * 
	 * @param event
	 *            Event,包含传输状态及进度值
	 */
	void handleEvent(Event event);

	/**
	 * 更新数据传输进度值(每2000毫秒调用次)
	 * 
	 * @param url
	 * @param progress
	 */
	void handleProgress(String url, float progress);
}

class MD5Util {
	/**
	 * 默认的密码字符串组合，用来将字节转换成 16 进制表示的字符,apache校验下载的文件的正确性用的就是默认的这个组合
	 */
	protected static char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c',
			'd', 'e', 'f' };

	protected static MessageDigest messagedigest = null;

	static {
		try {
			messagedigest = MessageDigest.getInstance("MD5");
		} catch (NoSuchAlgorithmException nsaex) {
			System.err.println(MD5Util.class.getName() + "初始化失败，MessageDigest不支持MD5Util。");
			nsaex.printStackTrace();
		}
	}

	/**
	 * 生成文件的md5校验值
	 * 
	 * @param file
	 * @return
	 * @throws IOException
	 */
	public static String getFileMD5String(File file) {
		String md5 = null;
		try {
			InputStream fis;
			fis = new FileInputStream(file);
			byte[] buffer = new byte[1024];
			int numRead = 0;
			while ((numRead = fis.read(buffer)) > 0) {
				messagedigest.update(buffer, 0, numRead);
			}
			fis.close();
			md5 = bufferToHex(messagedigest.digest());
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return md5;
	}

	private static String bufferToHex(byte[] bytes) {
		StringBuffer stringbuffer = new StringBuffer(2 * bytes.length);
		int k = 0 + bytes.length;
		for (int l = 0; l < k; l++) {
			// 取字节中高 4 位的数字转换, >>>为逻辑右移，将符号位一起右移,此处未发现两种符号有何不同
			char c0 = hexDigits[(bytes[l] & 0xf0) >> 4];
			char c1 = hexDigits[bytes[l] & 0xf];// 取字节中低 4 位的数字转换
			stringbuffer.append(c0);
			stringbuffer.append(c1);
		}
		return stringbuffer.toString();
	}

	public static void main(String[] args) throws IOException {
		long begin = System.currentTimeMillis();
		File file = new File("/sdcard/RSAKey.txt");
		String md5 = getFileMD5String(file);
		// String md5 = getMD5String("a");
		long end = System.currentTimeMillis();
		System.out.println("md5:" + md5 + " time:" + ((end - begin) / 1000) + "s");
	}
}
